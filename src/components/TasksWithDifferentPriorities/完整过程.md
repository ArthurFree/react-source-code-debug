这里以setState改变组件状态为例，重点突出更新过程的关键点，并给出关键代码，串联整个流程。

## 产生更新
当调用setState时，意味着fiber节点产生更新。实际上是通过组件上的updater来调用enqueueSetState，
```javascript
Component.prototype.setState = function(partialState, callback) {
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};

```
enqueueSetState的职责是创建update对象，入队updateQueue，发起调度。
```javascript
  enqueueSetState(inst, payload, callback) {
    // 获取当前触发更新的fiber节点。inst是组件实例
    const fiber = getInstance(inst);
    // eventTime是当前触发更新的时间戳
    const eventTime = requestEventTime();
    const suspenseConfig = requestCurrentSuspenseConfig();

    // 获取本次update的优先级
    const lane = requestUpdateLane(fiber, suspenseConfig);

    // 创建update对象
    const update = createUpdate(eventTime, lane, suspenseConfig);

    // payload就是setState的参数，回调函数或者是对象的形式。
    // 处理更新时参与计算新状态的过程
    update.payload = payload;

    // 将update放入fiber的updateQueue
    enqueueUpdate(fiber, update);

    // 开始进行调度
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  }
```
总结一下，调用setState时，首先准备调度所需的数据：update对象，优先级标记lane，eventTime。然后带着这些数据进入React的调度流程。

## 进入调度之前
scheduleUpdateOnFiber是进入调度流程的入口。它会将update的lane放到fiber树中，以便开展更新工作。然后根据lane的类型来决定进入同步更新流程
还是concurrent模式的更新流程。
```javascript
function scheduleUpdateOnFiber(fiber, lane, eventTime) {

  ...
  // 在root上标记更新
  const root = markUpdateLaneFromFiberToRoot(rootFiber, lane);

  ...

  if (lane === SyncLane) {
    // 同步调度
  } else {
    // concurrent模式的调度
    ensureRootIsScheduled(root, eventTime);
  }
    
}
```
由于每次的调度更新都是从root节点开始，所以它的首要任务是找到root。入参fiber是产生更新的节点，从它的return出发可以向上遍历到root。
但其实找到root不是主要目的，更重要的是这个过程中对于fiber节点、逐层的父节点以及root节点的各种优先级的标记。这些事情由` markUpdateLaneFromFiberToRoot`函数
完成。

本次update的优先级标记为lane，它首先会被放到fiber.lanes上，然后以fiber为起点，向上遍历，每遍历一个父fiber，就把lane放
入它的childLanes中。当遍历到父节点时，将lane放入root.pendingLanes。

*可以从[这里](https://github.com/neroneroffy/react-source-code-debug/blob/master/src/react/v17.0.0-alpha.0/react-reconciler/src/ReactFiberWorkLoop.new.js#L546)看到这个过程的完整代码*

这些操作都有什么意义呢？

* 关于fiber.lanes
基于双缓冲的概念，更新时，React会以现有的fiber树为原型，构建workInProgress树（此后的workInProgress简称为WIP），循环构建过程中，会以现有fiber
节点为基础新建WIP节点。所以WIP的lanes自然就是fiber.lanes，含有刚产生的update.lane。fiber.lanes用于将update的优先级同步给WIP节点。
* 关于childLanes
既然要从root开始向下更新，而root下面又有那么多子树，不能全部更新。那么就需要识别出某个fiber的子树是否需要更新，这也就是childLanes存在的意义。
若一个fiber节点的childLanes包含在renderLanes中，则说明子树有更新，否则跳过不处理。
* 关于root.pendingLanes
在render阶段，会以一个优先级来作为本次更新的基准，这就是渲染优先级：renderLanes。它来自root.pendingLanes中最紧急的那部分lanes。所以用
root.pendingLanes来存储update.lane就显得很必要了。

## 开始调度
在真正开始调度之前仍然要做准备工作，`ensureRootIsScheduled`函数中


2. 进入调度，将1产生的update的优先级标记（update.lane）放入fiber.lanes中和root的pendingLanes中，
并从fiber节点开始向上遍历，将lane放在父节点的childLanes中，最终收集到root.childLanes中。
3. 调用ensureRootIsScheduled，从root的pendingLanes中找出最紧急的那个优先级，作为本次渲染的渲染优先级（renderLanes），带着它进入render阶段更新。
4. 从beginWork开始，开始构建workInProgress树，处理到当时产生update的fiber时，基于它创建workInProgress节点，处理节点上的updateQueue，计算组件新的状态。
这一步包含一个关键逻辑，决定了低优先级任务被跳过以及之后被重新执行，具体在下一节会讲到。
5. 当beginWork处理到fiber树的叶子节点，开始completeUnitOfWork。这个阶段除了收集effectList，还将收集workInProgress节点上的lanes，最终
收集到root的childLanes中。这与第二步的过程相似但截然不同。第二步中的childLanes是未经处理的lanes。这一步中的则是已经处理过的。收集起来，以便决定
是否应再次发起调度进行处理。
6. render阶段完成，进入commit阶段。将上一步中为root收集的childLanes作为remainingLanes，赋值给root.pendingLanes。然后更新DOM，本次React
的更新任务完成。
7. 更新完成后，再次调用ensureRootIsScheduled，执行步骤3获取渲染优先级，若渲染优先级为空，则中断，否则继续调度。



## 高优先级任务插队，低优先级任务重做
一旦交互或者任何事件触发了更新，就会产生一个update对象，并持有一个优先级。该update会被放入组件对应的fiber节点的updateQueue中。

随后进入workLoop，开始构建workInProgress树。这个过程中若有高优先级的update产生，例如示例代码中的点击事件，会在root上标记有更新，并把优先级标记放入root
的pendingLanes。
```
export function markRootUpdated(root: FiberRoot, updateLane: Lane) {
  root.pendingLanes |= updateLane;
  ...
}
```
然后重新发起一个调度。值得注意的是，每次新的调度发起之前，
都会比较新任务的优先级与已有调度任务的优先级，来决定新任务是否可以插队。示例代码中，点击事件的优先级大于旧任务的优先级，于是取消旧任务的调度，重新为新任务发起调度。

调度发起后，在root上以concurrent模式执行任务。此时从root的pendingLanes中获取最紧急的任务:
performConcurrentWorkOnRoot函数中：
```
  let lanes = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
  );
```
react会带着这个lanes作为本次的渲染优先级，执行构建workInProgress树的工作循环。

当构建到产生更新的那个fiber节点，基于这个已有的fiber节点（称为current）创建workInProgress节点。然后在beginWork阶段，会处理workInProgress节点上的updateQueue。







关于第一点，将优先级放入workInProgress.lanes目的在于表明root的childLanes还有值。因为当高优先级任务完成更新后，root的childLanes会被作为剩余的优先级放入
root的pendingLanes。React会从pendingLanes找出最紧急的Lanes作为下一次渲染的优先级，一旦找出的渲染优先级为空，则不进行调度。
所以，以root为起点的更新任务是否会被调度，在于下一次渲染优先级是否存在。
关键代码如下：
```javascript
function ensureRootIsScheduled(root: FiberRoot, currentTime: number) {
  // 因为下次的渲染还没有被调度，所以现在确定的是下次的渲染优先级，和它们的优先级权重
  const newCallbackId = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
  );

  // newCallbackPriority会决定任务调度的情况
  const newCallbackPriority = returnNextLanesPriority();

  // 本次渲染优先级不存在，不进行调度
  if (newCallbackId === NoLanes) {
    // 不需要有所更新的话，取消掉之前的任务。
    if (existingCallbackNode !== null) {
      cancelCallback(existingCallbackNode);
      root.callbackNode = null;
      root.callbackPriority = NoLanePriority;
      root.callbackId = NoLanes;
    }
    return;
  }
  // 本次渲染优先级存在，依据优先级决定任务调度
  // .......
  // 这里省略了代码，只做简要描述。
  // 若有高优先级任务插队，需要取消上一次调度中断任务，重新调度。
  // 重新调度时，根据优先级来决定是走传统的同步调度还是concurrent模式的调度

  root.callbackId = newCallbackId;
  root.callbackPriority = newCallbackPriority;
  root.callbackNode = newCallbackNode;
}
```

当开始调度更新时，React会从root节点上的那些优先级中取出最紧急的，作为本次更新的渲染优先级，然后带着这个优先级一路向下构建workInProgress树。
遇到刚刚产生更新的workInProgress节点时，会处理它的updateQueue队列。

具体过程是依次处理队列中的update，处理之前用本次的渲染优先级和update的优先级作比较。若update的优先级包含在本次渲染优先级之中，进行处理，反之则跳过。
对下一个update进行同样的处理。

若update被跳过，则说明优先级不足，将它放到workInProgress节点中。这么做的目的是下次以被跳过update的优先级为渲染优先级进行渲染时，这个被跳过的update
能够被更新。

React会对Fiber上的updateQueue中的update依据本次渲染的渲染优先级和update的优先级决定眼前的这个update是被处理还是被跳过。

```
  constructor(props) {
    super(props)
    this.buttonRef = React.createRef();
  }
  state = { count: 0 }
  componentDidMount() {
    const button = this.buttonRef.current
    // 模拟常规优先级任务
    setTimeout( () => this.setState( { count: 1 } ), 500 )

    // 模拟用户操作，产生高优先级任务插队
    setTimeout( () => button.click(), 600)
  }
  handleButtonClick = () => {
    this.setState( prevState => {
      return { count: prevState.count + 2 }
    } )
  }
  render() {
    return <div className={"doms"}>
      <button ref={this.buttonRef} onClick={this.handleButtonClick}>增加2</button>
      <div>
        {Array.from(new Array(16000)).map( (v,index) =>
          <div key={index}>{this.state.count}</div>
        )}
      </div>
    </div>
  }
```
