React通过合成事件来弥合兼容问题，并提供和浏览器原生事件相同的接口。

React17事件机制的变动：
* 事件不再挂载到document上
* 废弃事件池
* 捕获阶段的事件监听直接采用原生 DOM 事件监听机制

# 事件注册
## 事件的优先级

# 事件对象的包装和事件收集
我们在事件中拿到的事件对象不是原生的事件对象，而是经过React包装过的`SyntheticEvent`对象。在浏览器的环境中，若父子元素绑定了相同类型的事件，
除非手动干预，那么依据事件冒泡或捕获，这些事件都会被触发，在React中也是如此。React是依据fiber树的结构，寻找到与原生的捕获和冒泡相同的事件触发路径，
对路径上的事件进行收集，自己模拟了一套事件捕获与冒泡的机制。

*下图是事件包装和收集（冒泡）的大致过程*
![事件包装和收集（冒泡）的大致过程](http://neroht.com/eventPath2.jpg)


事件的包装（生成事件对象）和收集发生在root上绑定的事件监听`dispatchDiscreteEvent`触发的时候，也就是我们真正触发事件的时候。每次都会重复这一过程。这与之前的版本不同，
之前的版本存在事件池的概念，可以复用事件对象，避免事件对象频繁地创建和释放引起的性能问题，但React17去掉了事件池，每次的事件对象都是会被重新创建的。

因为不同的事件会有不同的行为和处理机制，所以事件的包装和收集需要通过插件实现。一共有5种Plugin：**SimpleEventPlugin，EnterLeaveEventPlugin，
ChangeEventPlugin，SelectEventPlugin，BeforeInputEventPlugin**
它们的使命完全一样（合成 & 收集），只是处理的事件类别不同。本文只以`SimpleEventPlugin`为例来讲解，它处理比较通用的事件类型。比如`click、input、keydown`等。

## 包装事件对象

## 事件收集
事件收集是对事件目标元素的父元素逐层收集事件的过程，从而可以在事件触发时模拟冒泡或者捕获。

如下代码中的例子：目标元素是counter，父级元素是counter-parent，当点击counter时，父元素上的
点击事件也会被触发，实际上这是收集事件之后模拟冒泡导致的现象。
```javascript
class EventDemo extends React.Component{
  state = { count: 0 }
  onDemoClick = () => {
    console.log('counter的点击事件被触发了');
    this.setState({
      count: this.state.count + 1
    })
  }
  onParentClick = () => {
    console.log('父级元素的点击事件被触发了');
  }
  render() {
    const { count } = this.state
    return <div
      className={'counter-parent'}
      onClick={this.onParentClick}
    >
      <div
        onClick={this.onDemoClick}
        className={'counter'}
      >
        {count}
      </div>
    </div>
  }
}
```

这个过程会沿着从目标元素（counter） 到root这条路径，将途径的父元素上的同类事件收集到数组中，等待下一步的触发。收集过程发生在事件合成之后，执行之前。

![事件收集结果](http://neroht.com/eventTrigger.jpg)

我们可以看到，counter和counter-parent的事件都被收集到了一个数组中。被收集的不光有监听函数，还有绑定了事件的DOM实例和fiber对象。








# 事件执行

DOM事件的绑定在completeWork的这个过程
```javascript
function setInitialDOMProperties(
  tag: string,
  domElement: Element,
  rootContainerElement: Element | Document,
  nextProps: Object,
  isCustomComponentTag: boolean,
): void {
  for (const propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      ...
    } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
        ensureListeningTo(rootContainerElement, propKey, domElement);
      }
    }
  }
}
```
registrationNameDependencies是一个对象，存储了所有React事件对应的原生DOM事件的集合，
