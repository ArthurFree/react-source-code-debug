# 为什么要自己实现一套事件机制
由于React独有的fiber结构，这使得onClick这样的事件处理函数只能作为fiber节点的prop，而不是将事件一步到位地绑定到真实的DOM节点上。为此，React提供了一种“顶层注册，合成分发”的事件机制。
所谓“顶层注册”，其实是将事件处理函数统一绑定到root元素上，“合成分发”指的是事件触发时，构造合成事件对象，在fiber树内，将合成事件对象沿着事件冒泡或者捕获这样的路径分发到经过的DOM节点。

这套机制消除了挡在事件处理函数与真实DOM节点之间的隔阂（fiber树），并能够很好地利用fiber树的层级关系来模拟事件捕获以及冒泡，另外还带来两个非常重要的特性：
* 对事件进行归类，可以在事件产生的任务上包含不同的优先级
* 提供合成事件对象，抹平浏览器的兼容性差异

优先级的控制是在事件注册时决定的，抹平浏览器的兼容性差异是通过合成事件对象（SyntheticEvent）来实现的。

# 事件，从注册到执行
上面提到的这套事件机制的特点可以总结为三个：
1. 模拟事件捕获 & 冒泡
2. 事件优先级
3. 合成并分发事件对象
以上这三个特点在事件机制的不同阶段来完成。整个事件机制分为两个阶段：**注册 & 执行**，1和3发生在执行阶段，2发生在注册阶段。下面会分阶段讲一下整个机制的流程，重点突出这三个特点。


## 事件注册
与之前版本不同，React17的事件是注册到root上的，这主要是为了渐进升级，避免多版本的React共存的场景中事件系统发生冲突。

当我们为一个元素绑定事件时，会这样写：
```javascript
<div onClick={() => {/*do something*/}}>React</div>
```
这个div节点最终要对应一个fiber节点，onClick则作为它的prop。当这个fiber在渲染阶段进入completeWork时，onClick的prop会被识别为事件进行处理。

```javascript
function setInitialDOMProperties(
  tag: string,
  domElement: Element,
  rootContainerElement: Element | Document,
  nextProps: Object,
  isCustomComponentTag: boolean,
): void {
  for (const propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      ...
    } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
        // 如果propKey属于事件类型，则进行事件绑定
        ensureListeningTo(rootContainerElement, propKey, domElement);
      }
    }
  }
}
```
*registrationNameDependencies是一个对象，存储了所有React事件对应的原生DOM事件的集合，如果是事件类型的prop，那么将会调用ensureListeningTo去绑定事件。这是识别prop是否为事件的依据*

接下来的绑定过程可以概括为如下几个关键点：
* 根据React的事件名称寻找该事件依赖，例如onMouseEnter事件依赖了mouseout和mouseover两个原生事件，onClick只依赖了click一个原生事件。
* 识别该事件是否是捕获阶段的事件，例如`onClickCapture`这样的React事件名称就代表是需要事件在捕获阶段触发。
* 根据`onClick`这样的在react中的事件名，找出对应的原生事件名，例如`click`，并根据上一步来判断是否需要在捕获阶段触发，调用`addEventListener`，将事件绑定到root元素上。
* 若事件需要更新，先移除事件监听，再重新绑定，绑定过程重复以上三步。

经过这一系列过程，事件监听器listener最终被绑定到root元素上。
```javascript
  // 根据事件名称，创建不同优先级的事件监听器。
  let listener = createEventListenerWrapperWithPriority(
    targetContainer,
    domEventName,
    eventSystemFlags,
    listenerPriority,
  );

  // 绑定事件
  if (isCapturePhaseListener) {
    ...
    unsubscribeListener = addEventCaptureListener(
      targetContainer,
      domEventName,
      listener,
    );
  } else {
    ...
    unsubscribeListener = addEventBubbleListener(
      targetContainer,
      domEventName,
      listener,
    );

  }

```
## 事件监听器listener是谁
上面提到的绑定事件的时候，事件的监听函数是listener，那么这个listener是我们直接在组件里写的事件处理函数吗？答案是否定的。通过上面可知，
调用`createEventListenerWrapperWithPriority`创造出了listener。

为什么要创建这么一个listener，而不是直接绑定写在组件里的事件处理函数呢？

其实从`createEventListenerWrapperWithPriority`这个函数名已经说出了答案：用优先级创建一个事件监听包装器。有两个重点：**优先级**和**事件监听包装器**。
这里的优先级是事件优先级（关于事件优先级的详细介绍请移步[React中的优先级](https://github.com/neroneroffy/react-source-code-debug/blob/master/docs/%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/React%E4%B8%AD%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7.md) ），
事件优先级是根据事件的交互程度划分的，优先级和事件名的映射关系存在于一个Map结构中。`createEventListenerWrapperWithPriority`会根据事件名或者传入的优先级返回不同级别的**事件监听包装器**。
总的来说，会返回三种事件监听包装器：

* dispatchDiscreteEvent: 处理离散事件
* dispatchUserBlockingUpdate：处理用户阻塞事件
* dispatchEvent：处理连续事件

这些包装器是真正绑定到root上的监听器，它们持有各自的优先级，当对应的事件触发时，调用的其实是这个包含优先级的监听器。

![](http://neroht.com/listener.jpg)

## 小结
现在我们应该能清楚两点：
1. 事件处理函数不是绑定到组件的元素上的，而是绑定到root上，这和fiber树的结构特点有关，即事件处理函数只能作为fiber的prop。
2. 绑定到root上的事件监听不是我们在组件里写的事件处理函数，而是一个持有事件优先级的监听器。

让我们从这个监听器入手，看看它做了什么。

## 事件监听器listener做了什么
一句话：负责以不同的优先级权重来派发事件。

比如一个元素绑定了onClick事件，那么点击它的时候，listener会被触发，它会**合成并分发事件对象**，之后在事件监听执行阶段，组件中真正的事件处理函数才会被触发。

也就是说绑定到root上的事件监听listener只是相当于一个传令官，它按照事件的**优先级**去安排接下来的工作：**事件对象的合成**、**事件执行路径的填充**、 **事件执行**，在后面的调度过程中，scheduler才能获知当前任务的优先级，
然后展开调度。

**如何将优先级传递出去？**

利用scheduler中的`runWithPriority`，通过调用它，将优先级记录到利用scheduler中，所以调度器才能在调度的时候知道当前任务的优先级。`runWithPriority`第二个参数，会去派发事件。

以用户阻塞的优先级级别为例：
```javascript
  runWithPriority(
    UserBlockingPriority,
    dispatchEvent.bind(
      null,
      domEventName,
      eventSystemFlags,
      container,
      nativeEvent,
    ),
  );
```

**派发事件是什么意思？**

由于React自己实现了一套事件系统，所以必然要实现原生浏览器事件冒泡&捕获的特点，派发可以理解为将事件按照冒泡或者捕获的路径（事件执行路径），一层层触发。派发的过程又可以细分为
**事件对象的合成** 、**将事件填充执行路径上，然后分发事件对象**、 **事件执行**
这个过程在源码中体现在`dispatchEventsForPlugins`函数中，函数体可看成两部分：**事件对象的合成和执行路径的填充** 、 **事件执行**
```javascript
function dispatchEventsForPlugins(
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  nativeEvent: AnyNativeEvent,
  targetInst: null | Fiber,
  targetContainer: EventTarget,
): void {
  const nativeEventTarget = getEventTarget(nativeEvent);
  const dispatchQueue: DispatchQueue = [];
  
  // 事件对象的合成，填充事件到执行路径上，分发合成事件对象
  extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer,
  );
  
  // 事件执行
  processDispatchQueue(dispatchQueue, eventSystemFlags);
}
```

## 事件对象的合成和事件路径的填充
在组件中的事件处理函数中拿到的事件对象并不是原生的事件对象，而是经过React合成的`SyntheticEvent`对象。它属于新的事件体系的亮点之一，为的是解决不同浏览器之间的兼容性差异。抽象成统一的事件对象，
解除开发者的心智负担。

当事件对象合成完毕，要做的就是事件执行路径的填充。什么是事件执行路径呢？

在浏览器的环境中，若父子元素绑定了相同类型的事件，除非手动干预，那么依据事件冒泡或捕获，这些事件都会被触发，在React中也是如此。React是依据fiber树的结构，寻找到与原生的捕获和冒泡相同的事件触发路径，
对路径上的事件进行收集，这个路径就是事件执行路径，通过它，React自己模拟了一套事件捕获与冒泡的机制。

在React源码中，事件执行路径体现在dispatchQueue这个对象里，完整的路径是它的listeners字段，它是一个数组，存储着收集好的事件。

*下图是事件对象的包装和填充事件执行路径（冒泡的路径为例）的大致过程*
![件对象的包装和填充事件执行路径（冒泡的路径为例）](http://neroht.com/eventPath2.jpg)

因为不同的事件会有不同的行为和处理机制，所以合成事件对象的构造和执行路径的填充需要通过插件实现。一共有5种Plugin：**SimpleEventPlugin，EnterLeaveEventPlugin，
ChangeEventPlugin，SelectEventPlugin，BeforeInputEventPlugin**
它们的使命完全一样，只是处理的事件类别不同，所以内部会有一些差异。本文只以`SimpleEventPlugin`为例来讲解这个过程，它处理比较通用的事件类型。比如`click、input、keydown`等。

以下是SimpleEventPlugin中构造合成事件对象并分发事件的代码
```javascript
function extractEvents(
  dispatchQueue: DispatchQueue,
  domEventName: DOMEventName,
  targetInst: null | Fiber,
  nativeEvent: AnyNativeEvent,
  nativeEventTarget: null | EventTarget,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
): void {
  const reactName = topLevelEventsToReactNames.get(domEventName);
  if (reactName === undefined) {
    return;
  }
  let EventInterface;
  switch (domEventName) {
    // 赋值EventInterface（接口）
  }

  // 构造合成事件对象
  const event = new SyntheticEvent(
    reactName,
    null,
    nativeEvent,
    nativeEventTarget,
    EventInterface,
  );

  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;

  if (/*...*/) {
    ...
  } else {
    // scroll事件不冒泡
    const accumulateTargetOnly =
      !inCapturePhase &&
      domEventName === 'scroll';

    // 事件对象分发 & 收集事件
    accumulateSinglePhaseListeners(
      targetInst,
      dispatchQueue,
      event,
      inCapturePhase,
      accumulateTargetOnly,
    );
  }
  return event;
}

```

### 创建合成事件对象
这个统一的事件对象由`SyntheticEvent`函数构造而成，它自己遵循W3C的规范又实现了一遍浏览器的事件对象接口，这样可以抹平差异，而原生的事件对象只不过是它的一个属性（nativeEvent）。

```javascript
  // 构造合成事件对象
  const event = new SyntheticEvent(
    reactName,
    null,
    nativeEvent,
    nativeEventTarget,
    EventInterface,
  );
```

### 事件执行路径的填充，分发事件对象
所谓事件执行路径的填充是从触发事件的目标元素开始，向上经过各层元素，对于绑定了相同事件的元素，将事件填充到数组中（dispatchQueue的listeners）的过程，
这个数组就是事件执行路径，通过它可以模拟冒泡或捕获。

先看一个例子，目标元素是counter，父级元素是counter-parent。

```javascript
class EventDemo extends React.Component{
  state = { count: 0 }
  onDemoClick = () => {
    console.log('counter的点击事件被触发了');
    this.setState({
      count: this.state.count + 1
    })
  }
  onParentClick = () => {
    console.log('父级元素的点击事件被触发了');
  }
  render() {
    const { count } = this.state
    return <div
      className={'counter-parent'}
      onClick={this.onParentClick}
    >
      <div
        onClick={this.onDemoClick}
        className={'counter'}
      >
        {count}
      </div>
    </div>
  }
}
```
当点击counter时，父元素上的点击事件也会被触发，相继打印出：
```
'counter的点击事件被触发了'
'父级元素的点击事件被触发了'
```

实际上这是将事件以冒泡的顺序填充到执行路径之后导致的。填充的过程由`accumulateSinglePhaseListeners`完成。
```javascript
accumulateSinglePhaseListeners(
  targetInst,
  dispatchQueue,
  event,
  inCapturePhase,
  accumulateTargetOnly,
);
```
函数内部最重要的操作无疑是填充事件执行路径，为了实现这一操作，需要在fiber树中从触发事件的源fiber节点开始，向上一直找到root，这就是一条完整的冒泡或者捕获的路径。
同时，沿途路过fiber节点时，根据事件名，从props中获取我们真正写在组件中的事件处理函数，push到路径中，等待下一步的批量执行。

> 无论事件是在冒泡阶段执行，还是捕获阶段执行，都以同样的顺序push到dispatchQueue的listeners中，而冒泡或者捕获事件的执行顺序不同是由于清空listeners数组的顺序不同。

注意，每次收集只会收集与事件源相同类型的事件，比如子元素绑定了onClick，父元素绑定了onClick和onClickCapture:
```javascript
<div
  className="parent"
  onClick={onClickParent}
  onClickCapture={onClickParentCapture}
>
  父元素

  <div
    className="child"
    onClick={onClickChild}
   >
     子元素
   </div>
```
那么点击子元素时，收集到dispatchQueue中的将是`onClickChild` 和 `onClickParent`。

*收集的结果如下*

![事件路径](http://neroht.com/eventTrigger.jpg)

我们可以看到，counter和counter-parent的事件都被收集到了一个数组中。被收集的不光有监听函数，还有绑定了事件的DOM实例和fiber对象，其中DOM实例会作为事件对象的currentTarget。

## 事件执行
经过上面的过程，事件被收集到了dispatchQueue中，之后的过程是从头到尾循环这个数组，依次调用每一项中的监听函数。
```javascript
export function processDispatchQueue(
  dispatchQueue: DispatchQueue,
  eventSystemFlags: EventSystemFlags,
): void {
  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
  for (let i = 0; i < dispatchQueue.length; i++) {
    const {event, listeners} = dispatchQueue[i];
    // 将事件监听交由processDispatchQueueItemsInOrder去触发
    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
  }
  // 捕获错误
  rethrowCaughtError();
}
```



