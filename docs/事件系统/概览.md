React为什么要自己实现一套事件系统呢？这还得从它的特点来看


# 事件注册
与之前版本不同，React17的事件是注册到root上的，这主要是为了渐进升级，避免多版本的React共存的场景中事件系统发生冲突。当我们为一个元素绑定事件时，会这样写：
```javascript
<div onClick={() => {/*do something*/}}>React</div>
```
这个div节点最终要对应一个fiber节点，onClick作为它的prop，当这个fiber在渲染阶段进入completeWork时，onClick的prop会被识别为事件进行处理。

事件注册过程的源码：
```javascript
function setInitialDOMProperties(
  tag: string,
  domElement: Element,
  rootContainerElement: Element | Document,
  nextProps: Object,
  isCustomComponentTag: boolean,
): void {
  for (const propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      ...
    } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
        ensureListeningTo(rootContainerElement, propKey, domElement);
      }
    }
  }
}
```
registrationNameDependencies是一个对象，存储了所有React事件对应的原生DOM事件的集合，如果是事件类型的prop，那么将会
调用ensureListeningTo去绑定事件。



# 事件对象的合成和分发
我们在事件中拿到的事件对象不是原生的事件对象，而是经过React包装过的`SyntheticEvent`对象。在浏览器的环境中，若父子元素绑定了相同类型的事件，
除非手动干预，那么依据事件冒泡或捕获，这些事件都会被触发，在React中也是如此。React是依据fiber树的结构，寻找到与原生的捕获和冒泡相同的事件触发路径，
对路径上的事件进行收集，自己模拟了一套事件捕获与冒泡的机制。

*下图是事件包装和收集（冒泡）的大致过程*
![事件包装和收集（冒泡）的大致过程](http://neroht.com/eventPath2.jpg)


事件的包装（生成事件对象）和收集发生在root上绑定的事件监听`dispatchDiscreteEvent`触发的时候，也就是我们真正触发事件的时候。每次都会重复这一过程。这与之前的版本不同，
之前的版本存在事件池的概念，可以复用事件对象，避免事件对象频繁地创建和释放引起的性能问题，但React17去掉了事件池，每次的事件对象都是会被重新创建的。

因为不同的事件会有不同的行为和处理机制，所以事件的包装和收集需要通过插件实现。一共有5种Plugin：**SimpleEventPlugin，EnterLeaveEventPlugin，
ChangeEventPlugin，SelectEventPlugin，BeforeInputEventPlugin**
它们的使命完全一样（包装 & 收集），只是处理的事件类别不同。本文只以`SimpleEventPlugin`为例来讲解包装和收集，它处理比较通用的事件类型。比如`click、input、keydown`等。

以下是SimpleEventPlugin中构造合成事件对象并分发事件的代码
```javascript
function extractEvents(
  dispatchQueue: DispatchQueue,
  domEventName: DOMEventName,
  targetInst: null | Fiber,
  nativeEvent: AnyNativeEvent,
  nativeEventTarget: null | EventTarget,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
): void {
  const reactName = topLevelEventsToReactNames.get(domEventName);
  if (reactName === undefined) {
    return;
  }
  let EventInterface;
  switch (domEventName) {
    // 赋值EventInterface（接口）
  }

  // 构造合成事件对象
  const event = new SyntheticEvent(
    reactName,
    null,
    nativeEvent,
    nativeEventTarget,
    EventInterface,
  );

  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;

  if (/*...*/) {
    ...
  } else {
    // scroll事件不冒泡
    const accumulateTargetOnly =
      !inCapturePhase &&
      domEventName === 'scroll';

    // 事件对象分发 & 收集事件
    accumulateSinglePhaseListeners(
      targetInst,
      dispatchQueue,
      event,
      inCapturePhase,
      accumulateTargetOnly,
    );
  }
  return event;
}

```

## 创建合成事件对象
了解一个事物的本质首先要了解它存在的意义，React为什么要自己封装一个合成事件的事件对象呢？目的就是针对浏览器的兼容性差异，抽象成统一的事件对象，解除开发者的心智负担。
这个统一的事件对象由`SyntheticEvent`函数构造而成，它自己遵循W3C的规范又实现了一遍浏览器的事件对象接口，这样可以抹平差异，而原生的事件对象只不过是它的一个属性（nativeEvent）。

```javascript
  // 构造合成事件对象
  const event = new SyntheticEvent(
    reactName,
    null,
    nativeEvent,
    nativeEventTarget,
    EventInterface,
  );
```

## 事件对象的分发
合成事件对象构造完成后，需要进行分发。所谓分发是从触发事件的目标元素开始，逐层向上经过元素，对于绑定了相同事件的元素，将合成事件对象发给该元素的事件的过程。之后将事件收集。
因为有了分发我们才可以在事件中拿到合成好的事件对象，有了收集过程才可以模拟事件冒泡或者捕获。

如下代码中的例子：目标元素是counter，父级元素是counter-parent，当点击counter时，父元素上的
点击事件也会被触发，实际上这是收集事件之后模拟冒泡导致的现象。
```javascript
class EventDemo extends React.Component{
  state = { count: 0 }
  onDemoClick = () => {
    console.log('counter的点击事件被触发了');
    this.setState({
      count: this.state.count + 1
    })
  }
  onParentClick = () => {
    console.log('父级元素的点击事件被触发了');
  }
  render() {
    const { count } = this.state
    return <div
      className={'counter-parent'}
      onClick={this.onParentClick}
    >
      <div
        onClick={this.onDemoClick}
        className={'counter'}
      >
        {count}
      </div>
    </div>
  }
}
```

这个过程会构造合成事件对象，沿着从目标元素（counter） 到root这条路径，将合成事件对象发给途经元素上的同类事件，之后收集事件到数组中，等待下一步的批量触发。

![事件收集结果](http://neroht.com/eventTrigger.jpg)

我们可以看到，counter和counter-parent的事件都被收集到了一个数组中。被收集的不光有监听函数，还有绑定了事件的DOM实例和fiber对象。


# 事件执行

