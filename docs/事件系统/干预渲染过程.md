UI产生交互的根本原因是各种事件，这也就意味着事件与渲染有着直接关系。在React中，人为地将事件划分了等级。另外为了及时响应高优任务，各种更新任务也需要一套优先级规则，以此保证高优任务先于低优任务执行。而更新任务本质由事件产生，因此更新任务的优先级本质上是来自于事件的优先级。
# 优先级
React执行任务的重要依据是优先级，这里的任务不只是更新任务，还包括调度任务。优先级共分为三种：事件优先级、调度优先级、更新优先级。

## 事件优先级
在如此多的事件中，按照事件的紧急程度，一共有三个等级：
* 离散事件（DiscreteEvent）：click、keydown、focusin等，这些事件的触发不是连续的，优先级为0。
* 用户阻塞事件（UserBlockingEvent）：drag、scroll、mouseover等，特点是连续触发，阻塞用户交互，优先级为1。
* 连续事件（ContinuousEvent）：canplay、error、audio标签的timeupdate和canplay，优先级最高，优先级为2。
事件往往是更新任务的诱因，更新任务要经过Scheduler调度，因此事件优先级是计算调度优先级和更新由优先级的基础。事件的优先级在注册阶段就已经被确定了，在向root上注册事件时，会
根据事件的类别，注册持有不同优先级的listener。
```javascript
let listener = createEventListenerWrapperWithPriority(
    targetContainer,
    domEventName,
    eventSystemFlags,
    listenerPriority,
  );
```
`createEventListenerWrapperWithPriority`函数中按照不同事件，返回listenerWrapper
```javascript
export function createEventListenerWrapperWithPriority(
  targetContainer: EventTarget,
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  priority?: EventPriority,
): Function {
  const eventPriority =
    priority === undefined
      ? getEventPriorityForPluginSystem(domEventName)
      : priority;
  let listenerWrapper;
  switch (eventPriority) {
    case DiscreteEvent:
      listenerWrapper = dispatchDiscreteEvent;
      break;
    case UserBlockingEvent:
      listenerWrapper = dispatchUserBlockingUpdate;
      break;
    case ContinuousEvent:
    default:
      listenerWrapper = dispatchEvent;
      break;
  }
  return listenerWrapper.bind(
    null,
    domEventName,
    eventSystemFlags,
    targetContainer,
  );
}

```

最终事件的执行是这个listenerWrapper以不同的优先级来执行事件处理函数。在ReactDOM中，`dispatchDiscreteEvent`和`dispatchUserBlockingUpdate`最终都会以
UserBlockingEvent的级别去执行事件处理函数。
## 更新优先级
事件触发，产生更新，也就是update，它会持有一个优先级，此优先级是由事件优先级计算得来。
这如何理解呢？我们上面说过，**最终事件的执行是listenerWrapper以不同的优先级来执行事件处理函数**，也就是事件的执行会伴随着一个优先级。以drag事件为例，
它的listenerWrapper是`dispatchUserBlockingUpdate`:
```javascript
function dispatchUserBlockingUpdate(
  domEventName,
  eventSystemFlags,
  container,
  nativeEvent,
) {

  ...

  runWithPriority(
    UserBlockingPriority,
    dispatchEvent.bind(
      null,
      domEventName,
      eventSystemFlags,
      container,
      nativeEvent,
    ),
  );

  ...

}
```
可以看到**runWithPriority**方法以**UserBlockingPriority**的优先级执行了`dispatchEvent`，这个操作会将UserBlockingPriority的优先级记录到Scheduler中。
而事件处理函数一旦调用了setState，就会创建update，在这之前会依据事件优先级来创建update的优先级：
```javascript
const classComponentUpdater = {
  enqueueSetState(inst, payload, callback) {
    ...

    // 依据事件优先级创建update的优先级
    const lane = requestUpdateLane(fiber, suspenseConfig);

    const update = createUpdate(eventTime, lane, suspenseConfig);
    update.payload = payload;
    enqueueUpdate(fiber, update);

    // 开始调度
    scheduleUpdateOnFiber(fiber, lane, eventTime);
    ...
  },
};
```
重点关注**requestUpdateLane**，它做的就是计算update的优先级，由于update的优先级粒度更细，有可能多个update是由同一类事件产生的，那么它们就要持有相同的优先级，所以在这两者之间
需要有一层转换关系，这就是`schedulerLanePriority`。
```javascript
export function requestUpdateLane(
  fiber: Fiber,
  suspenseConfig: SuspenseConfig | null,
): Lane {

  ...
  // 获取事件优先级
  const schedulerPriority = getCurrentPriorityLevel();

  let lane;
  if (
    (executionContext & DiscreteEventContext) !== NoContext &&
    schedulerPriority === UserBlockingSchedulerPriority
  ) {
    // 如果事件优先级是用户阻塞级别，则直接用InputDiscreteLanePriority去计算
    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
  } else {
    // 依据事件的优先级去计算schedulerLanePriority
    const schedulerLanePriority = schedulerPriorityToLanePriority(
      schedulerPriority,
    );
    ...
    // 根据事件优先级计算得来的schedulerLanePriority，去计算update的优先级(lane)
    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
  }
  return lane;
}
```
这个过程有两个参与者，分别是`事件优先级（schedulerPriority）、schedulerLanePriority`。转化过程是：
```
事件优先级 -> schedulerLanePriority -> update的优先级
```
update的优先级已经获取到，下一步会进入调度。

## 调度优先级
当事件被触发后，即产生了一个任务，之后Scheduler开始调度。调度优先级的作用是保证高优任务先执行。
* NoPriority（0）：无任何优先级
* ImmediatePriority（1）：立即执行，优先级最高，Sync模式采用这种优先级进行调度
* UserBlockingPriority（2）：用户阻塞，用户操作引起的调度任务采用该优先级调度
* NormalPriority（3）：默认的优先级
* LowPriority（4）：低优先级
* IdlePriority（5）：优先级最低，闲置的任务
这里出现频率较高的有**ImmediatePriority、UserBlockingPriority、NormalPriority**。任务调度具体采用哪种优先级和当前的update的优先级有直接关系。

事件触发，产生update，开始调度。调度之前会先依据update的优先级计算此次调度任务的优先级：
```javascript
function ensureRootIsScheduled(root: FiberRoot, currentTime: number) {
  ...
  if (newCallbackPriority === SyncLanePriority) {
    // 若update的优先级是同步的，同步去调度
    newCallbackNode = scheduleSyncCallback(
      performSyncWorkOnRoot.bind(null, root),
    );
  } else if (newCallbackPriority === SyncBatchedLanePriority) {
    // 若update的优先级是同步批量的，调度优先级为ImmediatePriority
    newCallbackNode = scheduleCallback(
      ImmediateSchedulerPriority,
      performSyncWorkOnRoot.bind(null, root),
    );
  } else {
    // 先依据update的优先级计算此次调度任务的优先级
    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(
      newCallbackPriority,
    );
    newCallbackNode = scheduleCallback(
      schedulerPriorityLevel,
      performConcurrentWorkOnRoot.bind(null, root),
    );
  }
  ...
}
```
我们重点关注**lanePriorityToSchedulerPriority**，它根据update的优先级去计算调度优先级。