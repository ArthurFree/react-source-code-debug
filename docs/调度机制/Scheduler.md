Scheduler作为一个独立的包，可以独自承担起任务调度的职责，你只需要将任务和任务的优先级交给它，它就可以帮你安排任务的执行，这就是React和Scheduler配合的模式。

React任务的本质是各种函数调用，比如fiber树的构建、commit阶段、useEffect的调用，函数的调用需要占用线程，若执行任务的时候正好有用户交互进来，那么基于js单线程的特点，用户的交互就要等待任务完成才能被响应。从用户的角度
来看，这显然是不合理的。

Scheduler的出现就是为了在一定程度上解决这个问题。它引入两个概念：调度任务优先级 & 时间片。优先级让任务按照自身的紧急程度按序执行，保证及时响应高优先级任务；
时间片规定的是一个任务在这一帧内最大的执行时间，保证页面不会因为任务执行时间过长而产生卡顿。

基于这两个概念，Scheduler围绕着它的核心目标 - 任务调度，衍生出了两大核心功能：任务队列管理 和 任务分段执行

# 任务队列管理
在Scheduler内部，把任务分成了两种：未过期的和已过期的，分别用两个队列存储，前者存到timerQueue中，后者存到taskQueue中。
当一个任务进来的时候，会根据它的过期时间，判断放到哪个队列中。

如果放到了taskQueue，那么立即开始调度一个回调函数，去执行它。

如果放到了timerQueue，那么会调度一个timeOut，时间间隔为该任务的过期时间与当前时间的差，到期后检查它是否过期，是则放入taskQueue，调度一个回调开始执行它，否则继续调度timeout去定期检查。

这两种队列都是小顶堆的数据结构，可以很快找出过期时间最早的任务，任务的过期时间则是根据优先级得出的，下面会提到。任务队列的管理需要**调度任务优先级**重度参与，
这样才能实现多个任务按照优先级排序。

# 任务分段执行
在当前帧的时间内（一般为16ms），任务执行的最大执行时间不会超过单个时间片的长度，一旦超时，必须中断，让位给更重要的工作，例如浏览器为了响应用户输入的绘制工作，
直到这一帧完成，才在下一帧继续这个任务，这就是任务分段执行的概念。


# 调度优先级
concurrentMode下的任务通过`scheduleCallback`完成调度，同步渲染模式的任务由`scheduleSyncCallback`完成。

以concurrentMode为例，假设现在有一个任务A，优先级用数字表示为97，这时出现一个任务B，优先级为98。

时间片

任务队列

任务执行

调度

