Scheduler作为一个独立的包，可以独自承担起任务调度的职责，你只需要将任务和任务的优先级交给它，它就可以帮你安排任务的执行，这就是React和Scheduler配合的模式。

React任务的本质是各种函数调用，比如fiber树的构建、commit阶段、useEffect的调用，函数的调用需要占用线程，若执行任务的时候正好有用户交互进来，那么基于js单线程的特点，用户的交互就要等待任务完成才能被响应。从用户的角度
来看，这显然是不合理的。

Scheduler的出现就是为了在一定程度上解决这个问题。它引入两个概念：调度优先级 & 时间片。优先级让任务按照自身的紧急程度按序执行，保证及时响应高优先级任务；
时间片规定的是一个任务在这一帧内最大的执行时间，保证页面不会因为任务执行事件过长而产生卡顿。

时间片的引入使得能够支持任务分段执行变得至关重要，也就是在当前帧的时间内（一般为16ms），任务执行一旦超过最大执行时间（单个时间片的长度），必须中断，
让位给更重要的工作，例如浏览器为了响应用户输入的绘制工作，然后在下一帧继续这个任务。


# 调度优先级
concurrentMode下的任务通过`scheduleCallback`完成调度，同步渲染模式的任务由`scheduleSyncCallback`完成。

以concurrentMode为例，假设现在有一个任务A，优先级用数字表示为97，这时出现一个任务B，优先级为98。

时间片

任务队列

任务执行

调度

