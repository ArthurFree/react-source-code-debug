
`commitPlacement`是插入节点的入口，功能明确，将需要插入的fiber节点称为目标节点。
1. 找到目标节点DOM层面的父节点（parent）
2. 根据目标节点类型，改变parent
3. 如果目标节点对应的DOM节点目前只有文字内容，类似`<div>hello</div>`，并且持有ContentReset的effectTag，那么插入节点之前先设置一下文字内容
4. 找到基准节点
5. 执行插入

```javascript
function commitPlacement(finishedWork: Fiber): void {
  ...

  // 找到目标节点DOM层面的父节点（parent）
  const parentFiber = getHostParentFiber(finishedWork);

  // 根据目标节点类型，改变parent
  let parent;
  let isContainer;
  const parentStateNode = parentFiber.stateNode;
  switch (parentFiber.tag) {
    case HostComponent:
      parent = parentStateNode;
      isContainer = false;
      break;
    case HostRoot:
      parent = parentStateNode.containerInfo;
      isContainer = true;
      break;
    case HostPortal:
      parent = parentStateNode.containerInfo;
      isContainer = true;
      break;
    case FundamentalComponent:
      if (enableFundamentalAPI) {
        parent = parentStateNode.instance;
        isContainer = false;
      }
  }
  if (parentFiber.effectTag & ContentReset) {
    // 插入之前重设文字内容
    resetTextContent(parent);
    // 删除ContentReset的effectTag
    parentFiber.effectTag &= ~ContentReset;
  }
  
  // 找到基准节点
  const before = getHostSibling(finishedWork);
  
  // 执行插入操作 
  if (isContainer) {
    // 在外部DOM节点上插入
    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
  } else {
    // 直接在父节点插入
    insertOrAppendPlacementNode(finishedWork, before, parent);
  }
}

```
如果是`HostRoot`或者`HostPortal`类型的节点，都是直接将目标节点插入到它们对应的外部节点上的。

# 找到基准节点

React插入节点的时候，分两种情况，新插入的DOM节点在它插入的位置是否已经有兄弟节点，没有，执行`parentInstance.appendChild(child)`，
有，调用`parentInstance.insertBefore(child, beforeChild)`。这个`beforeChild`是新插入的DOM节点的基准节点，它通过`getHostSibling`函数计算得出。

举个例子来说：

p为新生成的DOM节点。a为已存在且无变化的DOM节点。它们在fiber树中的位置如下，p需要插入到DOM树中，我们可以根据这棵fiber树
来推断出最终的DOM树形态。
```
                    Fiber树                    DOM树

                   div#root                  div#root
                      |                         |
                    <App/>                     div
                      |                       /   \
                     div                     p     a
                    /   
                   /     
 Placement  -->   p ----> <Child/>
                             |
                             a
  
```
可以看到，在Fiber树中，a是p的父节点的兄弟节点，而在DOM树中，p和a是兄弟节点的关系，p最后要插入到a之前。

按照以上的图示我们来推导一下过程：

**p有兄弟节点`<Child/>`，它有子节点a，a是一个原生DOM节点，并且a已存在于DOM树，那么a作为结果返回，p插入到a之前。**

再来一个例子，p同样也是新插入的节点，h1作为已有节点存在于DOM树中。

```
                      Fiber树           DOM树

                     div#root         div#root
                        |                |
                      <App/>            div
                        |               /  \
                       div             p   h1
                      /   
                     /     
               <Child1/>--><Child2/>
                  |            |
                  |            |
 Placement  --->  p            h1
```
**p没有兄弟节点，往上找到`<Child1/>`，它有兄弟节点`<Child2/>`，`<Child2/>`不是原生DOM节点，找`<Child2/>`的子节点，发现了a，
a是原生DOM节点并且a已存在于DOM树，那么a作为结果返回，p插入到a之前。**

经过两个例子，getHostSibling寻找到新插入节点的兄弟DOM节点的过程可以总结为：
1. 优先查找同级兄弟节点，过滤出原生DOM组件。
2. 过滤不出来查找同级节点的子节点，过滤出原生DOM组件。
3. 重复查找兄弟节点再查找子节点的过程，直到再也找不到兄弟节点。
4. 向上查找到父节点，兄对父节点也重复前三步。
5. 直到过滤出原生DOM节点，判断它如果不是需要插入的节点，那么它作为结果返回，p需要插入到它的前面。

这其中有一个规律：

**`需要插入的节点`如果有同级fiber节点且是原生DOM节点，那么它一定是插入到这个节点之前的。如 果同级节点不是
原生DOM节点，那么它和同级节点的子节点`在DOM层面是兄弟节点`的关系。**

**`需要插入的节点`如果没有同级节点，那么它和父节点的兄弟节点的子节点`在DOM层面是兄弟节点`的关系。**

此时基准节点已经找到，接下来执行插入操作

## 插入节点
插入节点操作的是DOM树，只把目标节点插入还不够，需要遍历目标节点的fiber子树，保证所有DOM节点都被插入，遍历的过程是深度优先。



