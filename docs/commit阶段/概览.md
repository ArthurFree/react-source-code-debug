# 概览
当render阶段完成后，意味着在内存中构建的workInProgress树所有更新工作已经完成，这包括树中fiber节点的更新、diff、effectTag的标记、effectList的
收集。此时workInProgress树的完整形态如下：

![current树和workInProgress树](http://neroht.com/commitFiber.jpg)

和current树相比，它们的结构上固然存在区别，变化的fiber节点也存在于workInProgress树，但要将这些节点应用到DOM上却不会循环整棵树，而是通过循环effectList这个链表
来实现，这样保证了只针对有变化的节点做工作。

commit阶段的入口是`commitRoot`函数，它会告知scheduler以立即执行的优先级去调度commit阶段的工作。
```javascript
function commitRoot(root) {
  const renderPriorityLevel = getCurrentPriorityLevel();
  runWithPriority(
    ImmediateSchedulerPriority,
    commitRootImpl.bind(null, root, renderPriorityLevel),
  );
  return null;
}

```

`commitRootImpl`是commit阶段的核心实现，它内部被划分成三个阶段，来处理commit的工作。

# 三个阶段
整个commit阶段都是针对effectList的处理。这些处理可分为三个子阶段，每个子阶段都会从头到尾循环effectList。
* before mutation：读取组件变更前的状态，针对classComponent，调用getSnapshotBeforeUpdate，让我们可以在DOM变更前获取组件实例的信息。
* mutation：对需要改变DOM的节点（effectTag包含Placement、Update、PlacementAndUpdate、Deletion），进行相应的DOM操作。针对类组件，调用componentWillUnmount
* layout：在DOM操作完成后，读取组件的状态，针对类组件调用生命周期componentDidMount和componentDidUpdate

```javascript
function commitRootImpl(root, renderPriorityLevel) {

  // 准备阶段-----------------------------------------------

  const finishedWork = root.finishedWork;
  const lanes = root.finishedLanes;
  if (finishedWork === null) {
    return null;
  }
  root.finishedWork = null;
  root.finishedLanes = NoLanes;

  root.callbackNode = null;
  root.callbackId = NoLanes;
  
  // effectList的整理，将root上的effect连到effectList的末尾
  let firstEffect;
  if (finishedWork.effectTag > PerformedWork) {
    if (finishedWork.lastEffect !== null) {
      finishedWork.lastEffect.nextEffect = finishedWork;
      firstEffect = finishedWork.firstEffect;
    } else {
      firstEffect = finishedWork;
    }
  } else {
    // There is no effect on the root.
    firstEffect = finishedWork.firstEffect;
  }

  // 开始处理effectList
  if (firstEffect !== null) {
    
    ...
    
    // before mutation阶段--------------------------------
    nextEffect = firstEffect;
    do {...} while (nextEffect !== null);

    ...    
    
    // mutation阶段---------------------------------------
    nextEffect = firstEffect;
    do {...} while (nextEffect !== null);

    // 将wprkInProgress树切换为current树
    root.current = finishedWork;

    // layout阶段-----------------------------------------
    nextEffect = firstEffect;
    do {...} while (nextEffect !== null);

    nextEffect = null;

    // 通知Scheduler在帧的结尾让出执行权，来让浏览器有机会去绘制
    requestPaint();

  } else {
    // 没有effectList，直接将wprkInProgress树切换为current树
    root.current = finishedWork;
    
  }

  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;

  // 获取尚未处理的优先级，比如之前被跳过的任务的优先级
  remainingLanes = root.pendingLanes;

  /*
  * 每次commit阶段完成后，再执行一遍ensureRootIsScheduled，确保是否还有任务需要被调度。
  * 例如，高优先级插队的更新完成后，最后commit掉，还会再执行一遍，保证之前跳过的低优先级任务
  * 重新执行
  *
  * */
  ensureRootIsScheduled(root, now());

  ...

  return null;
}
```

fiber的effectList只包含子节点的effect，不包含它自身的，所以如果root节点有
    * 一个effect，需要把它放到effectList 的末尾，保证effectList里包含了所有的有
    * effect的fiber
不过在开始三个阶段的工作之前，还需要

