在React的concurrent模式下，低优先级任务执行过程中，一旦有更高优先级的任务进来，那么这个低优先级的任务会被取消，优先执行高优先级任务。等高优先级任务做完了，低优先级任务会被重新做一遍。

我们用一个具体的例子来理解一下高优先级任务插队。

有这样一个组件，state为0，进入页面，会调用setState将state加1，这个作为低优先级任务。React开始进行更新，
在这个低优先级任务尚未完成时，模拟按钮点击，state加2，这个作为高优先级任务。可以看到，页面上的数字变化为0 -> 2 -> 3，
而不是0 -> 1 -> 3。这就说明，当低优先级任务（加1）正在进行时，高优先级任务进来了，而它会把state设置为2。由于高优先级任务的插队，
设置state为1的低优先级任务会被取消，先做高优先级任务，所以数字从0变成了2。而高优先级任务完成之后，低优先级任务会被重做，所以state再从2加到了3。

现象如下：

![任务插队](http://neroht.com/result.gif)

利用chrome的性能分析工具捕捉更新过程，可以明显看到优先级插队的过程

![高优先级插队](http://neroht.com/高优先级插队.png)

完整的profile文件我保存下来了，可以载入到chrome中详细查看：[高优先级插队.json](https://github.com/neroneroffy/react-source-code-debug/blob/master/src/components/TasksWithDifferentPriorities/%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E6%8F%92%E9%98%9F.json) 。
[点击查看](https://github.com/neroneroffy/react-source-code-debug/blob/master/src/components/TasksWithDifferentPriorities/index.js) 高优先级插队示例代码文件。

接下来我们就来从setState开始，探讨一下这种插队行为的本质，内容涉及update对象的生成、发起调度、工作循环、高优任务插队、update对象的处理、低优先级任务重做等内容。

# 产生更新
当调用setState时，意味着组件对应的fiber节点产生了一个更新。setState实际上是生成一个update对象，调用enqueueSetState，将这个update对象连接到fiber节点的updateQueue链表中.
```javascript
Component.prototype.setState = function(partialState, callback) {
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};

```
enqueueSetState的职责是创建update对象，将它入队fiber节点的update链表（updateQueue），然后发起调度。
```javascript
  enqueueSetState(inst, payload, callback) {
    // 获取当前触发更新的fiber节点。inst是组件实例
    const fiber = getInstance(inst);
    // eventTime是当前触发更新的时间戳
    const eventTime = requestEventTime();
    const suspenseConfig = requestCurrentSuspenseConfig();

    // 获取本次update的优先级
    const lane = requestUpdateLane(fiber, suspenseConfig);

    // 创建update对象
    const update = createUpdate(eventTime, lane, suspenseConfig);

    // payload就是setState的参数，回调函数或者是对象的形式。
    // 处理更新时参与计算新状态的过程
    update.payload = payload;

    // 将update放入fiber的updateQueue
    enqueueUpdate(fiber, update);

    // 开始进行调度
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  }
```
梳理一下enqueueSetState中具体做的事情：

**找到fiber**

首先获取产生更新的组件所对应的fiber节点，因为产生的update对象需要放到fiber节点的updateQueue上。然后获取当前这个update产生的时间，这与更新的饥饿问题相关，我们暂且不考虑，而且下一步的suspenseConfig可以先忽略。

**计算优先级**

之后比较重要的是计算当前这个更新它的优先级lane：
```javascript
const lane = requestUpdateLane(fiber, suspenseConfig);
```
计算这个优先级的时候，是如何决定根据什么东西去计算呢？这还得从React的合成事件说起。

事件触发时，合成事件机制调用scheduler中的runWithPriority函数，目的是以该交互事件对应的事件优先级去派发真正的事件流程。runWithPriority会将事件优先级转化为scheduler内部的优先级
并记录下来。当调用requestUpdateLane计算lane的时候，会去获取scheduler中的优先级，以此作为lane计算的依据。

这部分的源码在[这里](https://github.com/neroneroffy/react-source-code-debug/blob/master/src/react/v17/react-reconciler/src/ReactFiberWorkLoop.old.js#L520)

**创建update对象， 入队updateQueue**

根据lane和eventTime还有suspenseConfig，去创建一个update对象，结构如下：
```javascript
const update: Update<*> = {
  eventTime,
  lane,
  suspenseConfig,
  tag: UpdateState,
  payload: null,
  callback: null,
  next: null,
};
```
* eventTime：更新的产生时间
* lane：表示优先级
* suspenseConfig：任务挂起相关
* tag：表示更新是哪种类型（UpdateState，ReplaceState，ForceUpdate，CaptureUpdate）
* payload：更新所携带的状态。
  - 在类组件中，有两种可能，对象（{}），和函数（(prevState, nextProps):newState => {}）
  - 根组件中，为React.element，即ReactDOM.render的第一个参数
* callback：可理解为setState的回调
* next：指向下一个update的指针

再之后就是去调用React任务执行的入口函数：`scheduleUpdateOnFiber`去调度执行更新任务了。

现在我们知道了，产生更新的fiber节点上会有一个updateQueue，它包含了刚刚产生的update。下面该进入`scheduleUpdateOnFiber`了，
开始进入真正的调度流程。通过调用`scheduleUpdateOnFiber`，render阶段的构建workInProgress树的任务会被调度执行，这个过程中，fiber上的updateQueue会被处理。

# 调度准备
React的更新入口是`scheduleUpdateOnFiber`，它区分update的lane，将同步更新和异步更新分流，让二者进入各自的流程。但在此之前，它会做几个比较重要的工作：
* 检查是否是无限更新，例如在render函数中调用了setState。
* 从产生更新的节点开始，往上一直循环到root，目的是收集fiber.childLanes，childLanes是识别这个fiber子树是否需要更新的关键。
* 在root上标记更新，也就是将update的lane放到root.pendingLanes中，每次渲染的优先级基准：renderLanes就是取自root.pendingLanes中最紧急的那一部分lanes。
这三步可以视为更新执行前的准备工作。

第1个可以防止死循环卡死的情况。

第2个是基于现有fiber树构建新的fiber树（workInProgress树）时，判断当前子树是否有更新的重要依据，若有更新，则继续向下构建，否则直接复用已有的fiber树，就不往下循环了，
可以屏蔽掉那些无需更新的fiber节点。

第3个是将当前update对象的lane加入到root.pendingLanes中，保证真正开始做更新任务的时候，获取到update的lane，从而作为本次更新的渲染优先级（renderLanes），去更新
> 实际上在更新时候获取到的renderLanes，并不一定包含update对象的lane，因为有可能它只是一个较低优先级的更新，有可能在它前面有高优先级的更新

梳理完`scheduleUpdateOnFiber`的大致逻辑之后，我们来看一下它的源码：
```javascript
export function scheduleUpdateOnFiber(
  fiber: Fiber,
  lane: Lane,
  eventTime: number,
) {
  // 第一步，检查是否有无限更新
  checkForNestedUpdates();

  ...
  // 第二步，向上收集fiber.childLanes
  const root = markUpdateLaneFromFiberToRoot(fiber, lane);

  ...

  // 第三步，在root上标记更新，将update的lane放到root.pendingLanes
  markRootUpdated(root, lane, eventTime);

  ...

  // 根据Scheduler的优先级获取到对应的React优先级
  const priorityLevel = getCurrentPriorityLevel();

  if (lane === SyncLane) {
    // 本次更新是同步的，例如传统的同步渲染模式
    if (
      (executionContext & LegacyUnbatchedContext) !== NoContext &&
      (executionContext & (RenderContext | CommitContext)) === NoContext
    ) {
      // 如果是本次更新是同步的，并且当前还未渲染，意味着主线程空闲，并没有React的
      // 更新任务在执行，那么调用performSyncWorkOnRoot开始执行同步任务

      ...

      performSyncWorkOnRoot(root);
    } else {
      // 如果是本次更新是同步的，不过当前有React更新任务正在进行，
      // 而且因为无法打断，所以调用ensureRootIsScheduled
      // 目的是去复用已经在更新的任务，让这个已有的任务
      // 把这次更新顺便做了
      ensureRootIsScheduled(root, eventTime);
      ...
    }
  } else {

    ...   
 
    // Schedule other updates after in case the callback is sync.
    // 如果是更新是异步的，调用ensureRootIsScheduled去进入异步调度
    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, lane);
  }

  ...
}
```
> `scheduleUpdateOnFiber` 的完整源码在[这里]()，这里是第二步：[markUpdateLaneFromFiberToRoot]() 和 第三步： [markRootUpdated]()的完整源码，我都做了注释。

经过了前面的准备工作后，`scheduleUpdateOnFiber`最终会调用`ensureRootIsScheduled`，来让React任务被调度，这是一个非常重要的函数，它关乎**同等或较低任务的收敛**、
**高优先级任务插队**、**低优先级任务重做**和**任务饥饿问题**，下面详细讲解它。

# 开始调度
在开始讲解`ensureRootIsScheduled`之前，我们有必要弄清楚React的更新任务的本质。

## React任务的本质
一个update的产生最终会使React在内存中根据现有的fiber树构建一棵新的fiber树，新的state的计算、diff操作、以及一些生命周期的调用，都会在这个构建过程中进行。这个整体的构建
工作被称为render阶段，这个render阶段整体就是一个完整的React更新任务，更新任务可以看作执行一个函数，这个函数在concurrent模式下就是`performConcurrentWorkOnRoot`，
更新任务的调度可以看成是这个函数被scheduler按照任务调度优先级安排它何时执行。

当一个任务被调度之后，scheduler就会生成一个任务对象（task），它的结构如下所示，暂时不需要关心它内部字段的意义。
```javascript
  var newTask = {
    id: taskIdCounter++,
    // 任务函数，也就是 performConcurrentWorkOnRoot
    callback,
    // 任务优先级
    priorityLevel,
    // 任务开始执行的时间点
    startTime,
    // 任务的过期时间
    expirationTime,
    // 在小顶堆任务队列中排序的依据
    sortIndex: -1,
  };
```
每当生成了一个这样的任务，它就会被挂载到root节点的`callbackNode`属性上，以表示当前已经有任务被调度了，同时会将任务调度优先级存储到root的`callbackPriority`上，
表示如果有新的任务进来，必须用它的任务调度优先级和root.callbackPriority（已有任务的调度优先级）比较，来决定是否有必要取消已经有的任务。

上面这段话其实就是`ensureRootIsScheduled`所作的主要工作之一。

## 任务优先级

## 任务协调 - ensureRootIsScheduled
我们了解了React任务的本质，其实`ensureRootIsScheduled`存在的意义只有一个：根据任务优先级去**协调任务的调度**，任务优先级有三类：
* 同步优先级：React传统的同步渲染模式产生的更新任务所持有的优先级
* 同步批量优先级：同步模式到concurrent模式过渡模式：blocking模式（[介绍](https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#migration-step-blocking-mode)）产生的更新任务所持有的优先级
* 其他优先级：concurrent模式产生的更新持有的优先级

接下来梳理一下任务协调的过程，在此只关注concurrent模式下的任务协调。对于第一个进来的任务，`ensureRootIsScheduled`会根据它的优先级来决定它进入哪种调度流程，concurrent模式下的





