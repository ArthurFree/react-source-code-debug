# 概述
React通过更新将新状态体现出来。每个更新需要有一个载体，这就是update对象。在React中，类组件与根组件使用一类update对象，函数组件使用
另一类update对象，但是都遵循一套类似的处理机制。暂且先以类组件的update对象为主进行讲解。

# 相关概念
update对象作为更新的载体，必然要存储更新的信息
```javascript
const update: Update<*> = {
  eventTime,
  lane,
  suspenseConfig,
  tag: UpdateState,
  payload: null,
  callback: null,
  next: null,
};
```
* eventTime：更新的产生时间
* lane：表示优先级
* suspenseConfig：任务挂起相关
* tag：表示更新是哪种类型（UpdateState，ReplaceState，ForceUpdate，CaptureUpdate）
* payload：更新所携带的状态。
  - 在类组件中，有两种可能，对象（{}），和函数（(prevState, nextProps):newState => {}）
  - 根组件中，为React.element，即ReactDOM.render的第一个参数
* callback：可理解为setState的回调
* next：指向下一个update的指针

在组件上有可能产生多个update，所以对于fiber来说，不是直接存储的update。它需要将可能出现的多个update放到一个队列中，所以在fiber上还会存储
一个更新队列，这就是updateQueue，它会以链表形式存储多个update对象。
```javascript
const queue: UpdateQueue<State> = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
    },
    effects: null,
  };
```
* baseState：前一次更新计算得出的状态，它是第一个被跳过的update之前的update计算得出的state。新的更新过程会以它为基础计算本次的状态
* firstBaseUpdate：前一次更新时updateQueue中第一个被跳过的update对象
* lastBaseUpdate：前一次更新中，updateQueue中以第一个被跳过的update为起点一直到的最后一个update截取的队列中的最后一个update。
* shared.pending：存储着本次更新的update队列
* effects：数组。保存update.callback !== null的Update

有几点需要解释一下：
1. 关于产生多个update对象的场景，多次调用setState即可
```javascript
this.setState({val: 2});
this.setState({val: 6});
```
产生的updateQueue结构如下：
![](https://neroht.com/updateQueue.jpg)
可以看出它是个单向的环装链表
```
  u1 ---> u2
  ^        |
  |________|
   
```
2. 关于firstBaseUpdate 和 lastBaseUpdate，它们两个其实组成的也是一个链表：baseUpdate。

以当前这次更新为基准，这个链表存储的是上次updateQueue中第一个被跳过的低优先级的update，到队列中最后一个update之间的那些update。
比如有如下的updateQueue：
```
A1 -> B2 -> C1 -> D2
```
Lanes模型中，可理解为数越小，优先级越高，所以 1 > 2

第一次以1的优先级处理队列，遇到B2时，跳过。直到这次更新完成处理完updateQueue，此时的baseUpdate链表为
```
B2 -> C1 -> D2
```
第二次以2的优先级处理队列，对这次来说，updateQueue中的baseUpdate链表就是上面的结构。

这样做的目的是保证最终全部处理完的结果与预期结果保持一致。也就是说，尽管`A1 -> B2 -> C1 -> D2`第一次以优先级为1去计算的结果为AC，但最终
的结果要是ABCD，因为这与队列中的4个update对象依次的处理结果相同，当然这个过程需要baseState的参与。

这里先给出了结论，不明白不要紧，下边会详细剖析updateQueue的处理原则。

# 更新的处理原则

# 总结

